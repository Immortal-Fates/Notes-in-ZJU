

# Main Takeaway

ZJU嵌入式系统



<!--more-->

# Tips

期末60（A4）+平时40（作业+实验）



# 概述

![image-20240228114830607](markdown-img/嵌入式系统.assets/image-20240228114830607.png)

- MPU：Micro Processor Unit
- MCU：Micro Controller Unit
- DSP：digital signal processor
- SoC：system on Chip嵌入式片上系统

操作系统

- 实时操作系统
- 非实时操作系统：Linux...

![image-20240228115219330](markdown-img/嵌入式系统.assets/image-20240228115219330.png)









# 数电

[【知识点总结】数字电子技术（数电）-CSDN博客](https://blog.csdn.net/weixin_51130221/article/details/126584659)

【【数字电子技术】清华阳哥10h期末速成课-哔哩哔哩】 https://b23.tv/PYy5UF3

## 数电基础

### 逻辑电平

仅高低电平

- 正逻辑体制：高1，低0（一般）
- 负逻辑体制：高0，低1

![image-20240228120314116](markdown-img/嵌入式系统.assets/image-20240228120314116.png)

> 尽量使用CMOS（范围更大）

### 数制和码制

二-十进制代码——BCD码

- 8421码
- 余3码：8421+$(0011)_2$

进位制/基数/位权

- 整数部分“除基取余法”
- 小数部分“乘基取整法”

原/反/补——补码的补码=原码

- 正数补码和原码相同
- 负数补码=反码（原码数值位取反）+1



### 逻辑运算

基本运算：

and or not(后面加个小圈就代表not)

![image-20240317221613713](markdown-img/嵌入式系统.assets/image-20240317221613713.png)

复合运算：

![image-20240317221914978](markdown-img/嵌入式系统.assets/image-20240317221914978.png)

基本公式：

![image-20240306153625210](markdown-img/嵌入式系统.assets/image-20240306153625210.png)

> 反演律：求非运算$(A\cdot B)`=A`+B`$​

基本定理：

反演定理+对偶定理

![image-20240317222815594](markdown-img/嵌入式系统.assets/image-20240317222815594.png)

![image-20240306185213665](markdown-img/嵌入式系统.assets/image-20240306185213665.png)

> 常用真值表来证明

逻辑门，三态门，OD门（OC门）

CMOS门电路

![image-20240306193107152](markdown-img/嵌入式系统.assets/image-20240306193107152.png)



### 逻辑代数表示

两种标准形式：

- 最小项之和
- 最小项之积

> 最小项表达式：最小项：每个变量都只出现一次（原变量为1，反变量为0，写成2进制）
>
> 最大项：A+B+C这样的三变量函数
>
> $m_0=A`B`C`,M_0=A+B+C,M_i=m_i`互补关系$

- 相邻性：两个最小项只有一个因子不同

  $ABC`+ABC=AB$​——两个相邻的最小项相加可以消去一个因子

- 可扩展性：任何的逻辑函数都可以表示为最小行之和的形式





- 真值表转换为逻辑表达式：将真值表中Y为1对应变量组合写成与项，（变量a）取值1为$a$,0为$\bar a$​​

  ![image-20240308060815773](markdown-img/嵌入式系统.assets/image-20240308060815773-1714295925130-53.png)


### 逻辑函数的化简方法

- 代数法

  - 提取公因子

  - 吸收法

  - 消项
    $$
    AB+A\prime C+BC=AB+A\prime C
    $$

  - 消因子法
    $$
    A+A\prime B=A+B
    $$
    

- 图解法（卡诺图法）

  合并相邻性最小项

  ![image-20240317231313535](markdown-img/嵌入式系统.assets/image-20240317231313535.png)

  > 注意编码不是顺序（格雷码），会有bounce

  - 逻辑函数写成最小项之和——可以直接填不用化成最小项之和
  - 画卡诺图，最小项填入1，0
  - 圈：相加合并最小项（包含2的n次幂个数，2、4、8）——消掉两个最小项中不同的那个数
    - 包含所有的1
    - 圈的数量越少越好
    - 圈的面积越大越好——注意最左和最右也相邻

  > 最简形式可能不唯一

- 带有无关项的卡诺图化简——无关项画×（可0可1）

  ![image-20240317233215574](markdown-img/嵌入式系统.assets/image-20240317233215574.png)

  带有约束条件即带有无关项

  ![image-20240317233440125](markdown-img/嵌入式系统.assets/image-20240317233440125.png)



### 数字集成电路



## 组合逻辑电路

小规模组合逻辑电路：分析方法+设计方法

中规模组合逻辑电路：编码器，译码器，数据选择器，加法器

### 小规模组合逻辑电路

输出仅与该时刻的输入有关（门电路组成，不含记忆元件）

- 设计方法

![image-20240313202849623](markdown-img/嵌入式系统.assets/image-20240313202849623.png)

- 逻辑抽象
  - 确定输入输出
  - 列真值表
- 化简函数，设计逻辑表达式（门电路，尺规作图）

![image-20240318101358360](markdown-img/嵌入式系统.assets/image-20240318101358360.png)

### 中规模组合逻辑电路

$$
十进制\stackrel{编码器}{\rightarrow}二进制\stackrel{译码器}{\rightarrow}十进制 
$$

- 编码器

  - 普通编码器——任何情况下只允许输入一个编码信号（浪费）

  - 优先编码器——可同时输入多个，根据优先权选择


![image-20240318103407874](markdown-img/嵌入式系统.assets/image-20240318103407874.png)

选通信号，附加信号

- 译码器

二——十进制译码器，`74L138`

显示译码器：七段字符显示器

![image-20240318103819480](markdown-img/嵌入式系统.assets/image-20240318103819480.png)

- 构造函数

  用最小项和写出逻辑函数；用与非门连接；完善输入端和使能端

![image-20240318105338006](markdown-img/嵌入式系统.assets/image-20240318105338006-1714295925130-54.png)

- 级联

  2片138译码器构成4-16译码器

  扩展输入端——使能端（控制芯片是否能正常工作，多芯片之间级联）

- 数值选择器——多位数值比较器

  ![image-20240318110333130](markdown-img/嵌入式系统.assets/image-20240318110333130.png)

  ![image-20240318110841484](markdown-img/嵌入式系统.assets/image-20240318110841484-1714295925130-55.png)

- 加法器

  - 1位加法器：半加器，全加器

    ![image-20240318111807179](markdown-img/嵌入式系统.assets/image-20240318111807179-1714295925130-57.png)

  - 多位加法器：串行进位加法器（慢），超前进位加法器（快，复杂）


### 竞争冒险

- 竞争：两个输入信号同时**向相反方向的逻辑电平跳变**的现象（即一个由1- > 0， 另一个从0 -> 1）——可能在输出产生尖峰脉冲
  - 接入滤波电容（脉冲很窄，需要电容很小
  - 引入选通脉冲

- 冒险：因竞争导致在输出端可能产生**尖峰脉冲**的现象

## 触发器

电路符号，（画波形图）特性表$Q*\rightarrow$特征方程

[数电：基本触发器、同步触发器、边沿触发器_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1EG411n7oe/?p=7&spm_id_from=pageDriver&vd_source=3a8e3df5af30a81c441200ce3c96e8fc)

### 各种触发器

按逻辑功能（RS, JK, D, T）——记住这4个特征方程；然后根据触发方式来判断什么时候变化

- SR锁存器（与非门和或非门构成）

  ![image-20240318113253499](markdown-img/嵌入式系统.assets/image-20240318113253499.png)

  ![image-20240318113630614](markdown-img/嵌入式系统.assets/image-20240318113630614.png)

  > Q当前时刻状态，Q*次态

- SR触发器

  ![image-20240313232756269](markdown-img/嵌入式系统.assets/image-20240313232756269-1714295925130-56.png)

  ![image-20240313232805556](markdown-img/嵌入式系统.assets/image-20240313232805556-1714295925130-58.png)

- D触发器

  特征方程；$Q^*=D$

  ![image-20240318114428261](markdown-img/嵌入式系统.assets/image-20240318114428261.png)

  > Cl高电平有效，前面有反向的圈则低电平有效

- JK触发器

  特征方程：$Q*=JQ`+K`Q$

  ![image-20240318115056478](markdown-img/嵌入式系统.assets/image-20240318115056478.png)

- T触发器——异或

  ![image-20240313233354584](markdown-img/嵌入式系统.assets/image-20240313233354584-1714295925130-59.png)

- T`触发器

  特征方程：$Q^*=Q`$，只有翻转功能

### 基本触发器

SR触发器

### 同步触发器

多了一个脉冲控制端——开关，根据Cl高低来控制（而不是边沿）

> 空翻：一个脉冲阶段变换2两次（不好）——改为边沿触发

**同步RS触发器**

- 当CP=0，保持$Q^*=Q$
- 当CP=1，与基本SR触发器相同

**同步D触发器**



### 边沿触发器

边沿触发的D触发器（上升沿有效）

Q*在上升沿来临时都会追随D的变化——抗干扰能力强

![image-20240313211235021](markdown-img/嵌入式系统.assets/image-20240313211235021.png)

（下降沿）——不止关注下降沿还要看下降沿来临前的脉冲阶段是否有状态的改变，如果有则在下降沿来临时改变状态

​	



## 时序逻辑电路

时序逻辑电路功能上：任一时刻的输出不仅取决于该时刻的**输入**（组合电路），还与电路原来的**状态**（触发器）有关

组合逻辑电路+存储电路

![image-20240318155542423](markdown-img/嵌入式系统.assets/image-20240318155542423.png)

输出方程，驱动方程，状态方程，（触发器本身的特性方程）





1. 时钟信号：同步时序电路与异步时序电路

同步：存储电路中所有触发器的时钟使用统一的clk,状态变化发生在同一时刻

异步：没有统一的clk,触发器状态的变化有先有后

2. 输出信号：Mealy型和Moore型

Mealy:$Y=F(X,Q)$

Moore:$Y=F(Q)$

### 小规模时序逻辑电路

#### 分析方法

![image-20240318163037193](markdown-img/嵌入式系统.assets/image-20240318163037193.png)

![image-20240318163725366](markdown-img/嵌入式系统.assets/image-20240318163725366-1714295925130-60.png)

计7的加法计数器

![image-20240619153441635](markdown-img/嵌入式系统.assets/image-20240619153441635.png)

#### 设计方法

分析问题找状态——状态编码——三大方程

![image-20240318165207533](markdown-img/嵌入式系统.assets/image-20240318165207533-1714295925130-61.png)

![image-20240318165216751](markdown-img/嵌入式系统.assets/image-20240318165216751-1714295925130-62.png)

### 中规模时序逻辑电路

[时序电路·专题04·计数器 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/573263886)

- 寄存器

  用于寄存一组二值代码，N位寄存器由N个触发器组成，可存放一组N位二值代码

  只要求其中每个触发器可置1，置0

- 移位寄存器=存储+移位

- 计数器：用于计数、分频、定时、产生节拍脉冲等
  - 同步计数器
  - 异步计数器
  - 同步加减计数器
  - 同步十进制计数
  - 减法计数器

![image-20240318201608004](markdown-img/嵌入式系统.assets/image-20240318201608004.png)

异步不等待CLK，同步会等待

同步异步计数器区分：

同步计数器的触发信号是同一个信号。具体来说，每一级的[触发器](https://zhidao.baidu.com/search?word=触发器&fr=iknow_pc_qb_highlight)接的都是同一个CLK信号。

异步计数器的触发信号时不同的，例如第一集的输出Q'作为第二局渣级的触发信号。

几进制的区分：看数据输出端得接线方法，当接线满足拿个计数时会导致“清零”端或者是“置数端”桐孙悄满足工作状态。导致这一计数状态之后回到零。这样子就很容易的判定计数器是几进制的了。

# MCS-51

## 嵌入式系统组成与设计方法

- 程序存储器：EPROM、EEPROM、Flash EEPROM以及OTP ROM等

- 数据存储器：80C51/52系列的单片机片内置有128B和256B的RAM；如果要求数据掉电保护，则需要采用Flash EEPROM作为数据存储器

- I/O
- A/D和D/A转换器：最著名的是美国的模拟数字器件公司（Analog）的一系列转换器

![image-20240328110102470](markdown-img/嵌入式系统.assets/image-20240328110102470.png)

软件部分：

- 设备驱动层

  ![image-20240328110445153](markdown-img/嵌入式系统.assets/image-20240328110445153.png)

  动层程序一般包括**硬件抽象层HAL**（Hardware Abstraction Layer，提高系统的可移植性）、**板极支持包BSP**（Board Support Package，提供访问硬件设备寄存器的函数包）和设备驱动程序

- 操作系统OS：OS是用来支持嵌入式应用的系统软件

  ![image-20240328110422932](markdown-img/嵌入式系统.assets/image-20240328110422932.png)

- 中间层

  ![image-20240328110436289](markdown-img/嵌入式系统.assets/image-20240328110436289.png)

- 应用程序层



- JTAG协议

- 在线编程目前有两种实现方法：
  - 在系统编程（ISP）：通过单片机专用的串行编程接口对单片机内部的Flash存储器进行编程
  - 在应用编程（IAP）：从结构上将Flash存储器映射为两个存储体，当运行一个存储体上的用户程序时，可对另一个存储体重新编程，之后将控制从一个存储体转向另一个

## 51基本结构

### 基本结构

MCS-51（8051）是一种**8位**CPU的单片机，由Intel公司于1981年在MCS48基础上推出的系列产品。

- 51系列：基本型

- 52系列：增强型

> PCA是单片机的一个功能模块：可编程计数器阵列——可用来实现PWM/捕捉/告诉输出等

![image-20240403131405031](markdown-img/嵌入式系统.assets/image-20240403131405031.png)

![image-20240403131424914](markdown-img/嵌入式系统.assets/image-20240403131424914.png)

- 引脚

  ![image-20240403132127950](markdown-img/嵌入式系统.assets/image-20240403132127950.png)

- 片外三总线结构![image-20240403132047282](markdown-img/嵌入式系统.assets/image-20240403132047282.png)



### CPU结构

| 运算器                 |                                                          |
| ---------------------- | -------------------------------------------------------- |
| 8位算数ALU逻辑运算单元 | 算数/逻辑/位运算                                         |
| 累加器A（ACC）         | 向ALU提供操作数、存放运算的中间结果、数据传送的中转站    |
| 寄存器B                | 主要用于乘、除                                           |
| 程序状态字寄存器PSW    | 8位寄存器，用于存放指令执行状态，供程序查询和判断        |
| **控制器**             |                                                          |
| 程序计数器PC           | 16位自动加1                                              |
| 堆栈指针寄存器SP       | 8位专用寄存器，存放堆栈栈顶存储单元的地址                |
| 数据指针寄存器DPTR     | 存放16位地址，用特定指令来访问片外数据存储器或程序存储器 |
| 指令寄存器IR           |                                                          |
| 定时和控制逻辑         |                                                          |

> PC (program counter)：PC的内容总是CPU将要执行的那条指令所存放的存储单元的首地址——CPU取指令，每取1个字节的内容，PC自动加1
>
> 一切分支/跳转/调用/中断/复位等操作的本质就是：**改变PC值**
>
> - 子程序调用和中断服务时CPU自动将当前PC值入栈保存，返回时自动将出栈**，**将原来保存过PC值复原

![image-20240403134153991](markdown-img/嵌入式系统.assets/image-20240403134153991.png)

### 存储器结构

51采用哈佛结构：程序存储器与数据存储器（含I/O接口）分开编址的方式；执行效率高，结构复杂

- 5类存储器：片内程序存储器，片外程序存储器，片内数据存储器，片外数据存储器，特殊功能寄存器

- 3个存储器地址空间：

  1、片内片外统一编址的64KB**程序存储器**地址空间（用16位地址)；

  2、片内数据存储器与特殊功能寄存器统一编址的256字节**内部数据存储器**地址空间（用8位地址)；

  3、64KB**片外数据存储器**地址空间（16位地址）



- 程序存储器

  ![image-20240403135210322](markdown-img/嵌入式系统.assets/image-20240403135210322.png)

  - 低4KB（0000H～0FFFH）的片外程序存储器和4K的片内程序存储器的**地址空间是公共的**，**控制信号EA**来区分片内和片外程序存储器 

  - 0000H ~ 0002H单元是系统的启动单元，所有程序的入口地址

    > 一般从0000H开始，存放一条**绝对转移指令**，用户程序则由转移后的地址开始执行，从而避开以上给系统使用的ROM单元

  - 0003H ~ 002AH单元，中断服务程序的入口地址，共40个单元，分成5段，**每段8个单元，分配给5个中断源**。用户程序不应该进入这个区域。

  - 程序存储器的0000H-002AH共43个单元用作**存储特定程序**的入口地址

    ![image-20240403140008644](markdown-img/嵌入式系统.assets/image-20240403140008644.png)

- 数据存储器

  ![image-20240403135633929](markdown-img/嵌入式系统.assets/image-20240403135633929.png)

  - 64KB数据存储器RAM在地址上是和64KB程序存储器ROM的**地址重叠**，8051通过**不同的信号**来选通RAM和ROM

  - 当对**片外RAM**读、写数据时，用**读、写控制信号RD或WR**来选通

  - 当对**片外ROM**取指令时，采用**选通信号PSEN** 

    > PSEN: 外部程序存储器的读/输出使能(Program Store Enable)信号输出端。该引脚作为外部程序存储器的控制信号，当CPU到外部程序存储器读取指令时。它的有效电平为低电平。



- 片内RAM——128字节

  [MCS-51单片机内部RAM可分为几个区？各区的主要作用是什么](https://blog.csdn.net/otangtang1234567/article/details/11677179)

  ![image-20240403141325523](markdown-img/嵌入式系统.assets/image-20240403141325523.png)

  - 00H ~ 1FH工作寄存器区：每8个为一组，共4组——是通用寄存器组：当程序切换（特别是被中断或抢占的时候）只需要切换一组寄存器就可以获得一组新的寄存器，而不必担心和别的程序冲突，也可以尽量少的进行入栈和出栈操作，提高运行效率

  - 20H ~ 2FH位寻址区：位地址00H ~ 7FH（128位）

  - 30H ~ 7FH：普通的数据缓存区，用来建立堆栈，还有放一些不太常用的数据

  - 以下需要注意，有两个80-FFH的数据区。

    其一：80-FFH，特殊功能寄存器组区，支持直接寻址，各种各样的特殊功能寄存器都在这里。

    > 特殊功能寄存器SFR（专用寄存器），不同SFR管理不同的硬件模块：编写软件要先对SFR进行设置——80C51有21个SFR

    其二：80-FFH，间接寻址区，这里只支持间接寻址，使用间接寻址指令避免和特殊功能寄存器区冲突。用来放一些不常用（相对不常用）的数据，由于使用R0或R1作指针寻址，用来建立数组数组是非常好的

访问片内RAM和片外RAM需要采用不同的寻址方式和指令。

- **访问片内RAM**：使用MOV指令。MOV指令用于在寄存器和片内RAM之间进行数据的传送。例如，将累加器A中的数据传送到片内RAM的某个单元，可以使用指令格式：`MOV 片内RAM单元地址, A`。

- **访问片外RAM**：使用MOVX指令。MOVX指令用于在寄存器和片外RAM之间进行数据的传送。例如，将累加器A中的数据传送到片外RAM的某个单元，可以使用指令格式：`MOVX @DPTR, A`。其中，DPTR是一个16位的数据指针寄存器，用于指向片外RAM的地址。



![image-20240529150259402](markdown-img/嵌入式系统.assets/image-20240529150259402.png)

### I/O口

功能：

- 基本输入输出功能（P1最单纯）

- 第二功能：有控制位进行选择

  ![image-20240403143714688](markdown-img/嵌入式系统.assets/image-20240403143714688.png)

- P0

  ![image-20240403151916759](markdown-img/嵌入式系统.assets/image-20240403151916759.png)

  - P0口在作为通用I/O口时**，**属于准双向口
  - P0口作为地址/数据总线使用时是一个真正的双向口

- P1

  ![image-20240403152438648](markdown-img/嵌入式系统.assets/image-20240403152438648.png)

  P1口是一个准双向I/O口

- P2

  ![image-20240403152403485](markdown-img/嵌入式系统.assets/image-20240403152403485.png)

- P3

  ![image-20240403152623230](markdown-img/嵌入式系统.assets/image-20240403152623230.png)

  P3在作为通用I/O口时，属于准双向口



- 带负载能力

  - P0口的每一位口线可以驱动**8个LSTTL负载**。在作为通用I/O口时，由于输出驱动电路是开漏方式，由集电极开路（OC门）电路或漏极开路电路驱动时需外接上拉电阻；当作为地址/数据总线使用时，口线输出不是开漏的，无须外接上拉电阻。
  - P1、P2、P3口的每一位能驱动**4个LSTTL负载**。它们的输出驱动电路设有内部上拉电阻，所以可以方便地由集电极开路（OC门）电路或漏极开路电路所驱动，而无须外接上拉电阻

  > LSTTL：Low-power Schottky TTL --低功耗肖特基TTL



- 典型应用：	

  - 片外三总线结构

    地址线：P0低八位地址，P2高八地址；16位地址总线

    数据线：P0输入输出8位数据；

    控制线：P3口的8位加上/PSEN、ALE共同完成 控制总线。

    P1口通常作为普通IO口使用

> 80C51的地址总线引脚包括P0口（P0.0到P0.7）和P2口（P2.0到P2.7）。在访问外部存储器时，P0口用于输出低8位地址，而P2口则用于输出高8位地址。



> ALE："Address Latch Enable"，即地址锁存使能
>
> **地址锁存**：在访问外部存储器（如外部RAM或外部ROM）时，ALE引脚用于锁存低8位地址信号。当8051单片机需要访问外部存储器时，它会将地址信号输出到地址总线上。其中，高8位地址信号通常由P2口提供，而低8位地址信号则由P0口提供。在每个机器周期的S2状态，ALE引脚会输出一个正脉冲，用于锁存P0口输出的低8位地址信号，以确保地址信号的稳定传输
>
> **固定频率输出**：当8051单片机没有访问外部存储器时，ALE引脚会以振荡器频率的1/6输出固定的正脉冲信号。这意味着，如果单片机的振荡器频率为6MHz，那么ALE引脚将以1MHz的频率输出正脉冲。这个功能使得ALE引脚可以用于外部时钟或定时器等应用
>
> **编程脉冲输入**：在某些型号的8051单片机（如8751）中，ALE引脚还具有编程脉冲输入的功能。在对片内带有可编程只读存储器（EPROM）的单片机进行程序固化时，ALE引脚可以作为编程脉冲的输入端





### 位处理器

布尔（位）处理器——作为微控制器的典型特诊，方便判断控制

| 位累加器       | 借用进位标志位CY                                  |
| -------------- | ------------------------------------------------- |
| 位寻址的RAM    | 内部RAM位寻址区中的0～127位(20H～2FH)             |
| 位寻址的寄存器 | 特殊功能寄存器（SFR**）**中的可以位寻址的位**。** |
| 位寻址的I/O口  | 并行 I/O口中的可以位寻址的位                      |
| 位操作指令系统 |                                                   |



### 单片机硬件的最小系统

最小系统：**工作电源、时钟电路、复位电路、存储器设置电路**

- 时钟接口电路——XTAL1+XTAL2产生振荡脉冲（分频后位系统使用）

  - 晶振频率：1.2 ~ 24MHz
  - 振荡电容：10 ~ 30pF(20pF)
  - 内部时钟/外部振荡

  ![image-20240403154513590](markdown-img/嵌入式系统.assets/image-20240403154513590.png)

  - 振荡脉冲的周期为**节拍P**；二分频后为**状态S**（一个状态包含2个P）；**机器周期**有6个状态（S1 ~ S6，共12个节拍S1P1,S1P2...S6P12）

    指令周期：**最大的时序定时单位**，执行一条指令所需要的时间

    可包含1、2、4个机器周期

    ![image-20240403155037609](markdown-img/嵌入式系统.assets/image-20240403155037609.png)

  - 时序：每一次ALE信号有效，CPU均从ROM中读取指令码（不一定有效，假读会丢弃），有效时PC++，无效时PC不变；

    其余时间用于执行指令操作功能，但在时序中没有完全反映出。如双字节单机器周期，分别在S1、S4读操作码和操作数，执行指令就一定在S2、S3 、S5 、S6中完成

- 复位：RST引脚输入高电平并至少保持两个机器周期

  ![image-20240403160809946](markdown-img/嵌入式系统.assets/image-20240403160809946.png)

  - 上电自动复位：上电瞬间RST获得高电平，电容C充电，RST电平逐渐下降

- 电源系统：VCC/GND（5V/3.3V）
  - 直流供电：开关电源+线性稳压电路
  - 交流供电：整流电路+开关电路或者新型稳压电路

### 工作方式

- 程序执行方式：从0000H开始

- 掉电保护方式：运行中突然掉电，先保存重要数据，启用备用电源维持供电

- 低功耗方式

  - 空闲方式(idle mode)：振荡器+外围电路工作，CPU睡眠——中断/硬件复位退出

  - 掉电方式(power down mode)：振荡器不工作——硬件复位退出

  - 电源控制寄存器**PCON**的有关控制位来控制的

    ![image-20240403161519091](markdown-img/嵌入式系统.assets/image-20240403161519091.png)
    
    ![image-20240526202752761](markdown-img/嵌入式系统.assets/image-20240526202752761.png)

- 编程方法？？？
  - 闪速存储器编程
  - 程序锁定为的功能和编程

## 51单片微机的指令系统

51单片机的指令系统包括111条指令，分为以下几类：

![image-20240410191507173](markdown-img/嵌入式系统.assets/image-20240410191507173.png)

[【MCS-51】51单片机指令系统大全](https://blog.csdn.net/m0_61151031/article/details/130028744)
$$
[标号:]操作码助记符 [操作数][;注释]
$$

- 标号：表示该语句的地址，1~8ASCII字母开头
- 操作码助记符：**唯一不能省略**，指明执行什么性质和类型的操作
- 操作数：给指令提供数据/地址
  - 各操作数之间必须用逗号间隔
  - 操作数和操作码之间用空格分隔
- 注释：`;`开头



### 汇编中数值表示

![image-20240417111250156](markdown-img/嵌入式系统.assets/image-20240417111250156.png)



### 指令格式及常用符号

- 单字节指令

  - 8位编码仅为操作码

    ![image-20240417111539726](markdown-img/嵌入式系统.assets/image-20240417111539726.png)

    > “A”表示累加器，ACC表示累加器对应的地址E0H

  - 8位编码=操作码(5 bits)+寄存器编码(3 bits)

    ![image-20240417111720403](markdown-img/嵌入式系统.assets/image-20240417111720403.png)

- 双字节指令

  - 第一byte表示操作码，第二byte表示数据/地址

    ![image-20240417111826270](markdown-img/嵌入式系统.assets/image-20240417111826270.png)

- 三字节指令
  - 第一byte表示操作码，后两个bytes表示数据/地址



### 常用符号

	（1）Rn（n=0~7）——选定当前工作寄存器组的通用寄存器R0-R7；
	（2）Ri（i=1或0）——通用寄存器中用于间接寻址片内RAM单元的两个寄存器R0、R1；
	（3）@ ——间接寻址寄存器指针的前缀标志；
	（4）direct ——片内RAM或SFR的8位直接地址；
	（5）#data ——8位直接参与操作的立即数，其中立即数为8位二进制数；
	（6）#data16 ——表示16位直接参与操作的立即数（仅用于指令MOV DPTR，#data16），其中立即数为16位二进制数；
	（7）# ——立即数前缀；
	（8）addr16 ——16位目的地址，供LCALL和LJMP指令使用；
	（9）addr11 ——11位目的地址，供ACALL和AJMP指令使用；
	（10）rel ——用补码形式表示的8位二进制偏移量，取值范围为-128~+127，常用于相对转移指令；
	（11）bit ——片内RAM的位寻址区，或者是可以位寻址的SFR的位地址；
	（12）/ ——位取反前缀，/bit表示位地址bit 的内容取反后再参与运算；
	（13）（x）——由x所指定的某寄存器或某单元中的内容；
	（14）（（x））——由x间接寻址存储器单元中的内容，即以x地址单元中的内容作为新地址的其单元中的内容；
	（15）＄——当前指令存放的地址；
	（16）← ——指令的操作结果是将箭头右边的内容传送到左边；
	（17）→ ——指令的操作结果是将箭头左边的内容传送到右边；
	（18）↔ ——指令的两个操作数内容互相交换。
	（19）A ——累加器。
	（20）B ——专用寄存器，用于乘法和除法指令。
	（21）C ——进位标志或进位位，或位处理器中的累加器。

### 寻址方式



7种方式

- 立即寻址

- 直接寻址

  A可直接寻址+寄存器寻址

- 寄存器寻址

- 寄存器间接寻址

  - 仅`R0,R1`能支持寄存器间接寻址

    `DPTR`

    `SP`仅用于堆栈操作


- 变址寻址：对程序存储器，只有读，`MOVC`
- 相对寻址
- 位寻址







### 数据传送类指令

数据传送类指令主要用于在寄存器、累加器、内部RAM、外部RAM和特殊功能寄存器之间进行数据的传输。包括以下指令：
- MOV：用于在寄存器、累加器、直接地址单元、间接地址单元和立即数之间进行数据的传输。
- PUSH：用于将直接地址单元中的数据压入堆栈。
- POP：用于将堆栈中的数据弹出到直接地址单元。
- XCH：用于交换寄存器、累加器和直接地址单元中的数据。

![image-20240529160044619](markdown-img/嵌入式系统.assets/image-20240529160044619.png)

在 51 系列单片机中，与外部存储器 RAM 打交道的只能是 A 累加器。所有需要传送入外部 RAM 的数据必需要通过 A 送去，而所有要读入的外部 RAM 中的数据也必需通过 A 读入。在此我们能看出内外部 RAM 的区别了，内部 RAM 间能直接进行数据的传递，而外部则不行，比如，要将外部 RAM 中某一单元（设为 0100H单元的数据）送入另一个单元（设为 0200H 单元），也必须先将 0100H 单元中的内容读入 A，然后再传送到 0200H 单元中去。  



### 数据处理类指令

数据处理类指令包括算术运算和逻辑运算指令。

#### 算术运算指令
- ADD：带进位加法

- SUBB：带借位减法

  ![image-20240618210120850](markdown-img/嵌入式系统.assets/image-20240618210120850.png)

- MUL AB：相乘，低8位放累加器A中，高8位放寄存器B中，若乘积大于FFH，则OV置1

- DIV：除法，商存于A中，余数存于B中，CY,OV均清0

- INC：把所指的寄存器内容+1，结果送回原寄存器——不影响标志位

- DEC：把所指的寄存器内容-1，结果送回原寄存器——不影响标志位

- DAA：用于对累加器中的数据进行十进制调整。

![image-20240418222357847](markdown-img/嵌入式系统.assets/image-20240418222357847-1714295925130-63.png)

#### 逻辑运算指令
- ANL：用于将累加器或寄存器中的数据与寄存器、直接地址单元或立即数进行逻辑与运算。
- ORL：用于将累加器或寄存器中的数据与寄存器、直接地址单元或立即数进行逻辑或运算。
- XRL：用于将累加器或寄存器中的数据与寄存器、直接地址单元或立即数进行逻辑异或运算。
- CPL：用于将累加器中的数据取反。
- RL：用于将累加器或寄存器中的数据左移。
- RLC：用于将累加器或寄存器中的数据循环左移。
- RR：用于将累加器或寄存器中的数据右移。
- RRC：用于将累加器或寄存器中的数据循环右移。
- SWAP：用于交换累加器中数据的高四位和低四位。

### 控制转移类指令
控制转移类指令用于改变程序的执行顺序，包括无条件转移、条件转移、循环和子程序调用等指令。

![image-20240418223005525](markdown-img/嵌入式系统.assets/image-20240418223005525-1714295925130-64.png)

```
;若A原始位00H
JNZ L1;不跳转
INC A;
JNZ L2;跳转到L2
```

```
CJNE A,direat,rel;这组指令的功能是对指定的目的字节和源字节进行比较，若它们的值不相等则转移
```

```
指令格式为JBC bit, rel，其中bit表示要判断的位，rel表示相对转移地址。
JBC指令的功能是：如果指定的位（bit）为1，则将该位清零（置为0），并进行相对转移，即程序跳转到当前地址加上相对转移地址rel的位置执行；如果指定的位（bit）为0，则不进行任何操作，程序顺序执行下一条指令。
位测试和位清零
```

```
DJNZ 操作数, 标号
DJNZ指令的功能是：将操作数的内容减1，然后判断操作数的结果是否为零。如果操作数减1后不为零，则跳转到指定的标号处继续执行；如果操作数减1后为零，则不进行跳转，继续执行下一条指令。
DJNZ指令通常用于循环结构中，通过不断减1并判断是否为零来控制循环的次数。
```

```
SJMP rel 直接跳转
SJMP指令的跳转范围是有限的，它只能跳转到当前程序存储器（如P0、P1、P2、P3）范围内的地址。如果需要跳转到更远的地址，可以使用其他类型的跳转指令，如LJMP（长跳转）或AJMP（绝对跳转）
```



### 位操作类指令

位操作类指令用于对寄存器或内存中的位进行操作，包括位传送、位逻辑和位控制等指令。

```
SETB 位地址
当执行SETB指令时，指令指定的位会被设置为1
```

![image-20240529171415850](markdown-img/嵌入式系统.assets/image-20240529171415850.png)





### 伪指令
除了上述指令外，51单片机还支持一些伪指令，用于定义变量、设置中断向量和生成程序起始地址等。这些伪指令在汇编程序时使用，但不会生成机器代码。



### 常用指令

```assembly
ORG 0H;"Origin" 的缩写，用于设置程序的起始地址。
SJMP ;跳转到指定的地址开始执行
DJNZ ;"Decrement and Jump if Not Zero" 先将指定的寄存器的值减1，然后检查结果是否为0
INC ; "Increment" 的缩写。这个指令将指定的寄存器的值加1
```

```assembly
INBUF: DB 10H DUP(?) ; 输入缓冲区,DB 是 "Define Byte" 的缩写，用于定义一个或多个字节的数据。DUP 是 "Duplicate" 的缩写，用于重复指定的数据,该缓冲区包含 10H（即16）个字节，每个字节的初始值是未定义的（用 ? 表示）。这个输入缓冲区用于存储要传送的字符串。
```



## 程序设计



### 汇编语言格式

```
ORG <addr> ;汇编起始地址命令
END 	   ;汇编终止命令
DB <8位数据表>

```



### 伪指令

















## C51编程

![image-20240425205627499](markdown-img/嵌入式系统.assets/image-20240425205627499-1714049815531-1-1714295925130-65.png)



### 数据类型

#### 变量

应用程序中使用的任何数据（变量和常量）必须以一定的存储器类型定位于单片机的相应的存储区域中**。**  

![image-20240425210209490](markdown-img/嵌入式系统.assets/image-20240425210209490-1714295925130-68.png)

> 片内RAM访问速度比片外RAM快得多，因此
>
> - 常用变量用bdata,data,idata来定义
> - 不常用/规模大的变量用pdata,xdata来定义

![image-20240425210424088](markdown-img/嵌入式系统.assets/image-20240425210424088-1714295925130-66.png)

#### 硬件结构

- 特殊功能寄存器`sfr sfr16`：`sfr 特殊功能寄存器名 = 地址常数`

  ![image-20240425210654326](markdown-img/嵌入式系统.assets/image-20240425210654326-1714295925130-71.png)

- 特殊功能寄存器特定位的定义`sbit`：`sbit 位变量名=特殊寄存器名^位的位置`

  ![更推荐](markdown-img/嵌入式系统.assets/image-20240425210826267-1714295925130-67.png)

  ![image-20240425210851011](markdown-img/嵌入式系统.assets/image-20240425210851011-1714295925130-70.png)

- 内部RAM中可位寻址对象的定义：当在内部RAM`20H~2FH`利用bdata存储器类型进行访问

  ![image-20240425211217706](markdown-img/嵌入式系统.assets/image-20240425211217706-1714295925130-69.png)’![image-20240425211345735](markdown-img/嵌入式系统.assets/image-20240425211345735-1714295925130-73.png)

  > 用关键字bit定义普通位变量时C51编译器会自行安排该位变量于可位寻址的bdata区。例如，`bit mybit`。
  >
  > Tips：不能定义bit类型的指针或数组



### 运算符和表达式

与C一样



### 函数

![image-20240425211751986](markdown-img/嵌入式系统.assets/image-20240425211751986-1714295925130-72.png)

- 编译模式：`SMALL,COPACT,LARGE`
- reentrant用于定义可重入函数
- interrupt n用于定义中断函数，n为中断号0~31
- using n用于确定中断服务函数所使用的工作寄存器组，n为工作寄存器组号0~3



寄存器传递方式最多可以传递3个函数——`REGPARMS,NOREGPARMS`

![image-20240425212108317](markdown-img/嵌入式系统.assets/image-20240425212108317-1714295925130-74.png)

![image-20240425212224678](markdown-img/嵌入式系统.assets/image-20240425212224678-1714295925130-75.png)



- 库函数：`reg51.h,reg52.h`



### 实例

- 中断

  ![image-20240425212437004](markdown-img/嵌入式系统.assets/image-20240425212437004-1714295925130-76.png)

  ![image-20240425212422413](markdown-img/嵌入式系统.assets/image-20240425212422413-1714295925130-77.png)

- 定时器



## 中断系统

中断返回指令RETI，子程序返回指令RET



### 中断系统结构

80C51中断系统结构：5个中断源，2个优先级，可实现二级中断嵌套

![image-20240522033459095](markdown-img/嵌入式系统.assets/image-20240522033459095.png)

#### 中断源

![image-20240522033547468](markdown-img/嵌入式系统.assets/image-20240522033547468.png)

![image-20240522033553574](markdown-img/嵌入式系统.assets/image-20240522033553574.png)

入口地址：...



### 中断控制

- 每个中断都有自己的请求标志

- 中断允许控制：CPU对中断系统所有中断以及某个中断源的开放和屏蔽是由中断允许寄存器IE控制的

  ![image-20240529211109650](markdown-img/嵌入式系统.assets/image-20240529211109650.png)

- 中断优先级设置：80C51单片机有两个中断优先级，即可实现二级中断服务嵌套。每个中断源的中断优先级都是由中断优先级寄存器IP中的相应位的状态来规定的

![image-20240522035335385](markdown-img/嵌入式系统.assets/image-20240522035335385.png)

三个原则：

- CPU同时接收到几个中断时， 首先响应优先级别最高的中断请求
- 正在进行的中断过程不能被新的同级或低优先级的中断请求所中断
- 正在进行的低优先级中断服务， 能被高优先级中断请求所中断

中断系统内部设有两个用户不能寻址的优先级状态触发器。 其中一个置1，表示正在响应高优先级的中断，它将阻断后来所有的中断请求；另一个置1，表示正在响应低优先级中断，它将阻断后来所有的低优先级中断请求  



### 中断处理过程

中断响应条件

- 中断源有中断请求；
- 此中断源的中断允许位为1
- CPU开中断（即EA=1）

> 通过硬件的LCALL指令转向中断向量的特定地址单元



中断响应过程

- 将相应的优先级状态触发器置1（以阻断后来的同级或低级的中断请求）。
- 执行一条硬件LCALL指令，即把程序计数器PC的内容压入堆栈保存，再将相应的中断服务程序的入口地址送入PC
- 执行中断服务程序



中断返回

![image-20240522035901457](markdown-img/嵌入式系统.assets/image-20240522035901457.png)



### Code

五个中断源的自然优先级与中断服务入口地址外中断0： 0003H定时器0： 000BH外中断 1： 0013H 定时器 1： 001BH 串行口： 0023H 它们的自然优先级由高到低排列  

```asm
ORG 0000H
LJMP START
ORG 0030H
START
```





## 定时器计数器

实现定时功能， 比较方便的办法是利用单片机内部的定时/计数器  

- 软件定时：常用循环（占CPU）
- 采用时基电路定时：不可编程
- 采用可编程芯片定时



### 结构

- 定时/计数器的实质是加1计数器（ 16位），由高8位和低8位两个寄存器组成。 
- TMOD是定时/计数器的工作方式寄存器，确定工作方式和功能； 
- TCON是控制寄存器，控制T0、T1的启动和停止及设置溢出标志。  

![image-20240522041113339](markdown-img/嵌入式系统.assets/image-20240522041113339.png)





### 工作原理

加1计数器输入的计数脉冲有两个来源

- 一个是由系统的时钟振荡器输出脉冲经12分频后送来
- 一个是T0或T1引脚输入的外部脉冲源  

![image-20240522041559966](markdown-img/嵌入式系统.assets/image-20240522041559966.png)

- 定时器模式，加1计数器是对内部机器周期计数（ 1个机器周期等于12个振荡周期，即计数频率为晶振频率的1/12）。 计数值N乘以机器周期Tcy就是定时时间t  

- 计数器模式

  ![image-20240522041853634](markdown-img/嵌入式系统.assets/image-20240522041853634.png)



### 控制

![image-20240522042732117](markdown-img/嵌入式系统.assets/image-20240522042732117.png)

![image-20240522042745383](markdown-img/嵌入式系统.assets/image-20240522042745383-1716323266169-1.png)



![image-20240522042809080](markdown-img/嵌入式系统.assets/image-20240522042809080.png)

![image-20240522042830829](markdown-img/嵌入式系统.assets/image-20240522042830829.png)

![image-20240529173028386](markdown-img/嵌入式系统.assets/image-20240529173028386.png)

![image-20240529184028975](markdown-img/嵌入式系统.assets/image-20240529184028975.png)

### 工作方式

- 方式0：13位定时/计数器,M!M0=00

  ![image-20240522042220033](markdown-img/嵌入式系统.assets/image-20240522042220033.png)

- 方式1：16位定时/计数器，M1M0=01

  ![image-20240522042310411](markdown-img/嵌入式系统.assets/image-20240522042310411.png)

- 方式2：自动再装入8位定时/计数器， M1M0=10  ，用得很少

  ![image-20240522042417430](markdown-img/嵌入式系统.assets/image-20240522042417430.png)

- 方式3：M1M0=11

  ![image-20240522042441103](markdown-img/嵌入式系统.assets/image-20240522042441103.png)

预置值计算：用最大计数量减去需要的计数次数即可  

### 应用

workflow：

![image-20240522042521801](markdown-img/嵌入式系统.assets/image-20240522042521801.png)



初始化分析：

![image-20240522042622446](markdown-img/嵌入式系统.assets/image-20240522042622446.png)

![image-20240522042628780](markdown-img/嵌入式系统.assets/image-20240522042628780.png)

![image-20240522042636131](markdown-img/嵌入式系统.assets/image-20240522042636131.png)





### Code

```
START： MOV TMOD， #01H ； T0 为定时器状态，工作方式 1
    MOV TL0， #0CH ； T0 的低位定时初值
    MOV TH0， #0FEH ； T0 的高位定时初值
    MOV TCON， #10H ；打开 T0
    SETB ET0 ； 1ET0，即允许 T0 中断
    SETB EA ； 1EA，即充许全局中断
    AJMP $ ；动态暂存
000BH： AJMP IST0 ；转入 T0 中断服务程序入口地址 IST0
    IST0： MOV TL0， #0CH ；重置定时器初值
    MOV TH0， #0FEH ；重置定时器初值
    CPL P1.0 ； P1.0 取反
    RET1 ；中断返回
```

![image-20240529230612443](markdown-img/嵌入式系统.assets/image-20240529230612443.png)

## 串行口原理及应用

![image-20240526212212343](markdown-img/嵌入式系统.assets/image-20240526212212343.png)

### 数据通信

$$
数据通信 = 数据处理 + 数据传输
$$

我们关心的是数据如何编码、如何传输、 通信接口、 通信协议  

![image-20240522185617182](markdown-img/嵌入式系统.assets/image-20240522185617182.png)



- 并行+串行

- 异步+同步

  - 异步：完整字符帧

  - 同步

    ![image-20240522190854819](markdown-img/嵌入式系统.assets/image-20240522190854819.png)

    要用标志序列来保持同步

- 全双工、半双工和单工



### 通信协议

串行通信协议有同步协议和异步协议两种  

通信速率是以每秒传送多少个二进制位来度量的，这个速率称作波特率（Baud Rate），其单位为bps（bits per second，位/秒）  



### 串行口结构与工作原理

![image-20240522192110537](markdown-img/嵌入式系统.assets/image-20240522192110537.png)



![image-20240522192207028](markdown-img/嵌入式系统.assets/image-20240522192207028.png)

- RS-232C接口信号的逻辑电平——负逻辑
- TTL信号的逻辑电平——正逻辑  

为了能够同计算机接口或终端的TTL器件连接，必须在RS-232C与TTL电路之间进行电平和逻辑关系的变换，采用MAX232芯片可完成TTL和EIA的双向电平转换  

![image-20240522192642808](markdown-img/嵌入式系统.assets/image-20240522192642808.png)

- 接收器部分：接收部分主要由一个数据接收缓冲寄存器（接收SBUF）和一个输入移位寄存器构成。串行接收的双缓冲结构  
- 发送器部分：发送器部分仅由一个具有移位功能的发送缓冲寄存器（发送SBUF）组成。单缓冲结构  

> SBUF是数据接收缓冲寄存器和数据发送缓冲寄存器的总称，两者共用一个地址为99H  

### 串行口的控制

SCON最为重要

![image-20240522193122120](markdown-img/嵌入式系统.assets/image-20240522193122120-1716377483209-1.png)

![image-20240526210924023](markdown-img/嵌入式系统.assets/image-20240526210924023.png)

![image-20240526210936679](markdown-img/嵌入式系统.assets/image-20240526210936679.png)

![image-20240526210945774](markdown-img/嵌入式系统.assets/image-20240526210945774.png)

![image-20240526211128949](markdown-img/嵌入式系统.assets/image-20240526211128949.png)



![image-20240522193314044](markdown-img/嵌入式系统.assets/image-20240522193314044.png)

![image-20240522193320539](markdown-img/嵌入式系统.assets/image-20240522193320539.png)

![image-20240522193333094](markdown-img/嵌入式系统.assets/image-20240522193333094.png)

SBUF register



### 串行口的工作方式

1. **方式0**：同步移位寄存器方式
   - **功能**：主要用于扩展并行输入或输出口，实现单片机与外部设备之间的数据交换。
   - **特点**：数据由RXD引脚输入或输出，同步移位脉冲由TXD引脚输出。发送和接收的数据均为8位，低位在先，高位在后。波特率固定为fosc/12。
2. **方式1**：8位异步通信方式
   - **功能**：用于实现单片机与外部设备之间的全双工异步通信。
   - **特点**：每帧数据包括1位起始位、8位数据位、1位停止位，共10位。数据位的低位在先，高位在后。波特率可变，由定时器T1/的溢出率决定。
3. **方式2**：9位异步通信方式
   - **功能**：在方式1的基础上增加了一位数据位，用于奇偶校验或地址识别。
   - **特点**：每帧数据包括1位起始位、8位数据位、1位可编程位（用于奇偶校验或地址识别）和1位停止位，共11位。波特率固定，由振荡器频率决定。
4. **方式3**：9位异步通信方式（多机通信）
   - **功能**：用于多机通信系统，通过地址识别来实现不同设备之间的通信。
   - **特点**：与方式2类似，但增加了地址识别功能。通过设置SM2位和RB8位，可以实现对地址帧和数据帧的区分。

- 工作方式0

  ![image-20240522194515366](markdown-img/嵌入式系统.assets/image-20240522194515366.png)

  ![image-20240522194538403](markdown-img/嵌入式系统.assets/image-20240522194538403.png)

- 工作方式1

  ![image-20240522194609437](markdown-img/嵌入式系统.assets/image-20240522194609437.png)

  具体工作方式见PDF

- 工作方式2

  ![image-20240522194819409](markdown-img/嵌入式系统.assets/image-20240522194819613.png)

- 工作方式3

  ![image-20240522194954814](markdown-img/嵌入式系统.assets/image-20240522194954814.png)

  

### 计算

波特率的计算总结

![image-20240522195006484](markdown-img/嵌入式系统.assets/image-20240522195006484.png)

![image-20240604231408346](markdown-img/嵌入式系统.assets/image-20240604231408346.png)

### 串行口的应用

![image-20240522195150780](markdown-img/嵌入式系统.assets/image-20240522195150780.png)

#### 串行通信编程的程序流程

- 查询方式

  指令查询标志位TI和RI ：

  TI =1，一帧发送完， TI≠1，没有发送完

  RI=1，一帧数据已送到， RI≠1，没有送到

  

- 中断方式

  设置中断允许，以TI和RI作为中断请求标志位， TI=1或RI=1均可引发中断。

  > note： TI和RI两个标志位是以**硬件自动置1**，而以**软件清零的**。



以查询方式发送和接收的程序流程：

![image-20240526202353257](markdown-img/嵌入式系统.assets/image-20240526202353257.png)

以中断方式发送和接收的程序流程：

![image-20240526202408355](markdown-img/嵌入式系统.assets/image-20240526202408355.png)

![image-20240526202417827](markdown-img/嵌入式系统.assets/image-20240526202417827.png)



#### 多机通讯与应用



### Code

```
MAIN： MOV P1， #0FFH
LCALL DELAY
MOV P1， #00H
LCALL DELAY
LJMP MAIN
```

这段程序和前面做过的程序比较，只有两处不一样：第一句：原来是 SETB P1. 0，现在改为 MOV P1， #0FFH，第三句：原来是 CLR P1.0，现在改为 MOV P1.0， #00H。从中能看出， P1 是 P1.0~P1.7 的全体的代表，一个 P1 就表示了所有的这八个管脚了。当然用的指令也不一样了，是用 MOV 指令。为什么用这条指令？看图 2，我们把 P1作为一个整体，就把它当作是一个存储器的单元，对一个单元送进一个数能用 MOV 指令  



```
ORG 2000H ;1200 位/秒的定时器初值
    MOV TL1,#0F3H
    MOV TH1,#0F3H ;使 SMOD=0
    MOV PCON,#00H ;T1 方式 2
    MOV TMOD,#20H
    SETB EA
    CLR ET1 ;关闭 T1 中断
    SETB ES ;开串行中断
    SETB TR1 ;开 T1 定时
    MOV SCON,#40H ;串行方式 1
    CLR A
    MOV SBUF,A ;串行发送
    JNB T1,$ ;等待发送完
    CLR T1, ;清标志
    SJMP $
ORG 0023H ;串行中断入口地址
    MOV SBUF,A ;连续发送
    JNB T1,$
    INC A
    CLR T1
    RET1 ;中断返回
```





# 32











# References

- 