# Main Takeaway

数据结构与算法

看PhiFan即可，我仅整理我的收获——好的地方放链接（我就不转载了）

# 主定理

[数据结构与算法 - PhilFan's Notebook](https://www.philfan.cn/CS/DataStructure/)

## 时间复杂度

![image-20230101145242893](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20230101145242893.png)

![image-20230101145822408](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20230101145822408.png)

![image-20230101145831844](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20230101145831844.png)

## 法则

对数增长非常缓慢

主要考虑 最坏可能性 与 平均可能性

## 主定理

$$
T(n)=aT(\frac{n}{b})+f(n)
$$



# 链表

- 广义表——利用Union来将不同类型的节点使用相同结构

![image-20240228172003720](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240228172003720.png)

- 多重链表

  稀疏矩阵——采用十字链表（多重链表）；行指针+列指针把行、列串起来

  ![image-20240228172332745](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240228172332745.png)

  > term作为多重链表的入口

# 堆栈

> Q:计算机怎么计算表达式？
>
> 后缀表达式：从左到右扫描，逐个处理数和符号，O(N)

堆栈：先进后出 后进先出 `LIFO : last in first out`

push() 向栈输入 pop() 从栈输出

```
Top=-1；//代表堆栈空
```



# 队列

队列：先进先出 `FIFO : first in first out`

`enquene()`入队 `dequene()`出队



# Tree

- 结点的度(degree)：结点的子树个数

- 数的度：数的所有结点中最大的度数
- 叶结点：度=0

表示法：

- 儿子兄弟表示法——二叉树

  ![image-20240228183942772](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240228183942772.png)

## 二叉树

binary tree

左子树$T_L$+右子树$T_R$

![image-20240228184213792](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240228184213792.png)

- 斜二叉树
- 完美（满）二叉树，$2^{k}-1$
- 完全二叉树

![image-20240228184713307](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240228184713307.png)

> 遍历；判断是否为空；创建

### 遍历

二叉树遍历的核心问题：二维结构的线性化（存储结构：堆栈、队列）

![image-20240228184914451](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240228184914451.png)

- 非递归遍历算法——使用堆栈

- 层序遍历：构造队列，抛出一个，然后放入左右儿子

### 平衡二叉树AVL

深度和平均查找长度ASL

- BF(Balance Factor 平衡因子)：$BF(T)=h_L-h_R$​
- AVL： $|BF(T)|\leq1$

![image-20240228210005044](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240228210005044.png)

AVL调整：

- 右单旋RR旋转

  ![image-20240228210933078](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240228210933078.png)

- 左单旋LL旋转

- LR旋转



判断两个数是否相同：列序，比较左子树和右子树

## 哈夫曼树

Huffman Tree——WPL最小的二叉树

根据不同频率构造更有效的搜索树

![image-20240229232121335](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240229232121335.png)

- 构造：每次把全职最小的两棵二叉树合并



不等长

哈夫曼编码——避免二义性（采用二叉树，所有字符在叶结点上）















# 集合

并查集

双亲表示法：子指针指向父

采用数组存储形式

![image-20240229233242102](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240229233242102.png)

# 散列表



# 图论

Graph

- 多对多：V(vertex)顶点+E(edge)边

  > 不考虑重边和自回路；有向图，无向图

- 度：发出的边数“出度”，指向该点的边数“入度”

- 连通

  - 连通分量：无向图的极大连通子图（极大顶点数，极大边数）

  - （有向图）

    强连通：存在双向路径

    弱联通

- 邻接矩阵G\[N][N]——定义为值表示权重

  ![image-20240229234341172](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240229234341172.png)

- 邻接表：够稀疏才合算

## 遍历

- DFS（depth first search）深度优先搜索
- BFS（breadth first search）广度优先搜索



## 最短路径

无权图单源最短路径

有权图单源最短路径

- 负值圈（不考虑）

- Dijkstra算法——路径按递增的顺序生成（不能解决有负边的情况）

  ![image-20240301145016207](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240301145016207.png)

多源最短路径

- 将单源算法调用|V|遍（非稠密图更好）

- Floyd算法

  ![image-20240301145922330](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240301145922330.png)

## 最小生成树

Minimum Spanning Tree——都是贪心算法

E=V-1

![image-20240301150237367](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240301150237367.png)

- Prim算法——让一棵小数长大
- Kruskal算法——将森林合并成树（开始每个顶点都是一棵树，每次加入权重最小的边）

> 最小堆，并查集

## 拓扑排序

AOV网络(activity on vertex)——一般用于安排项目工序

![image-20240301151826396](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240301151826396.png)

机动时间

# 排序

只讨论内部排序

时间复杂度下界——逆序对inversion

- 冒泡排序

```
template <typename T>
void BubbleSort(T* arr, int len)
{
    for (int i = 0; i < len - 1; i++) {
    	flag == 0;
        for (int j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                T temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                flag = 1;
            }
        }
        if(flag==0)	break;
    }
}
```

- 插入排序

```
template <typename T>
void InsertSort(T* arr, int len)
{
    for (int i = 1; i < len; i++) {
        T temp = arr[i];
        int j = i - 1;
        while (j >= 0 && temp < arr[j]) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = temp;
    }
}
```

- 希尔排序（不同的增量序列）

```

```

- 选择排序
- 堆排序
- 有序子列归并
- 物理排序：按独立的环排序 `i==table[i]`
- 桶排序： 为每个数构造一个桶
- 基数排序：桶排序的进阶
  - 次位优先——数
  - 主位优先
  - 多关键字排序

# 散列表

处理动态变量——hash函数

符号表：name-attribute

- 装填因子：

  ![image-20240303151110188](C:\Users\Immortal\AppData\Roaming\Typora\typora-user-images\image-20240303151110188.png)

冲突

- 散列函数——放和找是一样的

## 数字关键词

- 直接寻址法

- 除留余数法

- 数字分析法

  ![image-20240303151731180](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240303151731180.png)

- 折叠法

- 平方取中法

  ![image-20240303152000730](https://raw.githubusercontent.com/Immortal-Fates/image_host/main/blog/image-20240303152000730.png)

## 字符关键词

-  ASCII码加和法

- 简单的改进——前3个字符移位法

# References

- [数据结构与算法 - PhilFan's Notebook](https://www.philfan.cn/CS/DataStructure/)
- ZJU陈越老师

