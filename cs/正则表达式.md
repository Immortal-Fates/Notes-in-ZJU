# Main Takeaway

根据[正则表达式30分钟入门教程 (deerchao.cn)](https://deerchao.cn/tutorials/regex/regex.htm)这篇文章来学习的正则表达式，文章介绍的是 .Net 下的正则表达式，其它环境下的具体情况可以在读完本文后去参考官方文档，或者查看[正则表达式引擎特性对比](https://deerchao.cn/tutorials/regex/diffs.html)。

> Tips:正则表达式学不了一点，看得头疼，偶的建议是了解点基础语法即可。有些要的时候再回头来看。

<!--more-->

# 简介

正则表达式就是记录文本规则的代码。常用于查找符合某些复杂规则的字符串的需要。

比**通配符**（wildcard:*和?）更精确，也更复杂

# 测试正则表达式

.Net下的工具 [Regester](https://deerchao.cn/tools/regester/)，直接测试

也可以试试这个在线测试工具：[Wegester, JavaScript正则表达式测试器。](https://deerchao.cn/tools/wegester/)

**常用的处理选项**：

| 名称                              | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| IgnoreCase(忽略大小写)            | 匹配时不区分大小写。                                         |
| Multiline(多行模式)               | 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) |
| Singleline(单行模式)              | 更改.的含义，使它与每一个字符匹配（包括换行符\n）。          |
| IgnorePatternWhitespace(忽略空白) | 忽略表达式中的非转义空白并启用由#标记的注释。                |
| ExplicitCapture(显式捕获)         | 仅捕获已被显式命名的组。                                     |

> Tips<处理多行>:如果选中了这个选项，^和$的意义就变成了匹配行的开始处和结束处。
>
> 多行模式和单行模式没任何关系，可以同时使用

# 注释

学习任何一样工具，我认为最首要的是学会如何写注释：

通过语法`(?#comment)`来包含注释

要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。

# 元字符

metacharater

| 代码 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| .    | 匹配除换行符以外的任意字符                                   |
| \w   | 匹配字母或数字或下划线或汉字                                 |
| \s   | 匹配任意的空白符（包括空格，制表符(Tab)，换行符，中文全角空格等） |
| \d   | 匹配数字                                                     |
| \b   | 匹配单词的开始或结束(只匹配一个位置，不匹配字符)             |
| ^    | 匹配字符串的开始                                             |
| $    | 匹配字符串的结束                                             |

- 避免重复书写：0\d{2}-\d{8}。这里\d后面的{2}({8})的意思是前面\d必须连续重复匹配2次(8次)。

> Tips:{5,12}和{2}是类似的，只不过{2}匹配只能不多不少重复2次，{5,12}则是重复的次数不能少于5次，不能多于12次，否则都不匹配。

| 代码/语法 | 说明             |
| --------- | ---------------- |
| *         | 重复零次或更多次 |
| +         | 重复一次或更多次 |
| ?         | 重复零次或一次   |
| {n}       | 重复n次          |
| {n,}      | 重复n次或更多次  |
| {n,m}     | 重复n到m次       |

- 字符转义：使用\\.和\\*来查找.和\*。当然，要查找\本身，你也得用\\.

- 字符类：在方括号里列出想匹配的字符集合即可

  > Tips:[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。

- 反义：有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义**

| 代码/语法 | 说明                                       |
| --------- | ------------------------------------------ |
| \W        | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S        | 匹配任意不是空白符的字符                   |
| \D        | 匹配任意非数字的字符                       |
| \B        | 匹配不是单词开头或结束的位置               |
| [^x]      | 匹配除了x以外的任意字符                    |
| [^aeiou]  | 匹配除了aeiou这几个字母以外的任意字符      |

# 分枝条件

用|把不同的规则分隔开，如果满足其中任意一种规则都应该当成匹配:

**eg**:`0\d{2}-\d{8}|0\d{3}-\d{7}`这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。

> Tips:**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。

# 分组

想要重复多个字符，可以用小括号来指定**子表达式**(也叫做**分组**)，然后你就可以指定这个子表达式的重复次数了。

eg:`(\d{1,3}\.){3}\d{1,3}`

## 后向引用

默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

**后向引用**用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。

| 分类         | 代码/语法                                                    | 说明                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 捕获         | (exp)                                                        | 匹配exp,并捕获文本到自动命名的组里                           |
| (?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) |                                                              |
| (?:exp)      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号               |                                                              |
| 零宽断言     | (?=exp)                                                      | 匹配exp前面的位置                                            |
| (?<=exp)     | 匹配exp后面的位置                                            |                                                              |
| (?!exp)      | 匹配后面跟的不是exp的位置                                    |                                                              |
| (?<!exp)     | 匹配前面不是exp的位置                                        |                                                              |
| 注释         | (?#comment)                                                  | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |

# 贪婪与懒惰

- 贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。
- 懒惰匹配：**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。

懒惰限定符：

| 代码/语法 | 说明                            |
| --------- | ------------------------------- |
| *?        | 重复任意次，但尽可能少重复      |
| +?        | 重复1次或更多次，但尽可能少重复 |
| ??        | 重复0次或1次，但尽可能少重复    |
| {n,m}?    | 重复n到m次，但尽可能少重复      |
| {n,}?     | 重复n次以上，但尽可能少重复     |

# Bonus

文章中还有零宽断言、负向零宽断言、平衡组/递归匹配等知识我并未做记录，或许得等到我真正需要用到的时候再使用吧。

# References

- [Python-100-Days/Day01-15/12.字符串和正则表达式.md at master · jackfrued/Python-100-Days (github.com)](https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.字符串和正则表达式.md)
- [正则表达式30分钟入门教程 (deerchao.cn)](https://deerchao.cn/tutorials/regex/regex.htm)
