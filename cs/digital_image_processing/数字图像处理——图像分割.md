# Lec 10 图像分割

从图像中提取信息

1. 图像分割→得到对象或者区域
2. 特征提取→以适合计算机处理的形式描述和表示分割的区域
3. 计算机视觉→进行图像识别和解释

Segment Anything Model -- SAM

## 基础知识

图像分割操作强烈依赖以下两种方式

- 不连续性——基于强度值的突变进行分割

  点检测、线检测、边缘检测

- 相似性——基于强度值的相似性进行分割

  國值分割、区域生长、区域分裂及合并、聚类方法等

- 边缘：最基本的图像特征之一，可以表达物体的特征，边缘特征对于图像的变化不敏感



## 点、线、边缘检测

灰度图像边缘提取，主要的思想：

- 抑制噪声（低通滤波、平滑、去噪、模糊）

- 边缘特征增强（高通滤波、锐化）

  几何变化，灰度变化，光照方向变化

- 边缘定位

提取三种灰度不连续的基本类型：点，线，边缘。而提取的方法是卷积运算
$$
g(x, y) = \sum_{x=-a}^{a} \sum_{y=-b}^{b} w(s, t) f(x - s, y - t)
$$
几种微分算子——模板系数之和为零

> 在灰度值相近的区域（低频区域），算子模板的应用使其灰度值接近0

- 一阶导数：边缘时一阶微分的极值点
  - 一阶导数通常在图像中产生**更粗的边缘**
  - 一阶导数通常对灰度阶跃有更强的响应

- 二阶导数：边缘时二阶微分的过零点
  - 二阶导数对**精细细节**有较强的响应
  - 二阶导数在灰度过渡处会产生双边缘响应
  - 二阶导数的符号可用于确定边缘的变化是从亮到暗还是从暗到亮
  - 对噪声非常敏感

边缘检测步骤：

1. 图像平滑以减少噪音

2. 计算局部导数

3. 一阶导的幅值可以用来检测边缘的存在

4. 二阶导的符号可以用来决定边缘的像素是处于一张图片的局部亮面还是暗面

5. 二阶导的过零点位于边缘强度变化区域的中点，这提供了一个用于边缘定位的强大方法




下面介绍几种常用的算子：

- Prewitt

  ```
  -1 0 +1	    +1 +1 +1
  -1 0 +1		 0  0  0
  -1 0 +1		-1 -1 -1
  ```

  近似一阶微分，去噪+增强边缘

- Sobel

  ```
  -1 0 +1	    +1 +2 +1
  -2 0 +2		 0  0  0
  -1 0 +1		-1 -2 -1
  ```

  近似一阶微分，去噪+增强边缘

- Kirsch罗盘核

- 拉普拉斯算子：对噪声具有无法接受的敏感性，不能检测边缘的方向

  对二阶导数的近似，用于估计导数的幅度
  $$
  \Delta I = \nabla^2 I = \frac{\partial^2 I}{\partial x^2} + \frac{\partial^2 I}{\partial y^2}
  $$

  ```
   0 -1  0	    -1 -1 -1
  -1  4 -1		-1  8 -1
   0 -1  0		-1 -1 -1
  ```

  问题
  - 作为一个二阶导数，拉普拉斯算子对噪声具有无法接受的敏感性
  - 拉普拉斯算子的幅值产生**双边缘**
  - 拉普拉斯算子无法计算梯度，因此不能检测边缘的方向

  解决方法
  - 对图像先进行平滑 → LoG (Laplacian of a Gaussian)
  - 利用零交叉特性进行边缘定位
  - 不用于梯度方向，而是用于确定像素位于边缘的暗侧或亮侧

- LoG (Laplacian of a Gaussian)：在拉普拉斯算子前先进行平滑，不用于梯度方向，而是用于确定像素位于边缘的暗侧或亮侧

  利用零交叉特性进行边缘定位：零交叉点可用于定位粗边缘的中心

  考虑一个高斯函数$$h(r) = -e^{-\frac{r^2}{2\sigma^2}}$$

  其中 $  r^2 = x^2 + y^2  $，$  \sigma  $ 是标准差。用一副图像与该函数卷积，则模糊该图像

  $  h  $ 的拉普拉斯算子 (Laplacian of a Gaussian, LoG) 是

  $$
  \nabla^2 h(r) = -\left[\frac{r^2 - \sigma^2}{\sigma^4}\right] e^{-\frac{r^2}{2\sigma^2}}
  $$
  用 LoG 和一幅图像进行卷积，相当于先使用高斯平滑函数 $  h  $ 对图像进行卷积，然后对卷积结果求拉普拉斯

  > 斜坡开始处，二阶导数为负，斜坡结束二阶导数为正，斜坡上，二阶导数为0.（亮到暗边缘）
  > 零交叉点的定义：零灰度轴和二阶导数极值的连线的交点称为该二阶导数的零交叉点
  >
  > ![image-20250403104205600](E:/notes_in_zju/docs/notes/cs/assets/数字图像处理与机器视觉.assets/image-20250403104205600.png)
  >
  > 二阶导数提取边缘往往产生**双边缘**。而通过求零交叉点可以确定边缘的中心，从而避免了产生双边缘的不方便

- Marr-Hildreth边缘检测子

  Marr-Hildreth边缘检测器由LoG滤波器与一幅输入图像 $f(x, y)$ 卷积组成，即

  $$
  g(x, y) = [\nabla^2 G(x, y)] * f(x, y)
  $$

  寻找 $g(x, y)$ 的零交点来确定 $f(x, y)$ 中边缘的位置。由线性操作，有

  $$
  g(x, y) = [\nabla^2 G(x, y) * f(x, y)]
  $$
  数字图像用Marr-Hildreth边缘检测器进行边缘检测的基本步骤：

  1. 用一个对下式取样得到的n×n的高斯低通滤波器对输入图像滤波
     $$
     G(x, y) = e^{-\frac{x^2 + y^2}{2\sigma^2}}
     $$

  2. 计算由第一步得到的图像的拉普拉斯

  3. 找到第二步的零交叉

  > 可以简单讲Marr-Hildreth算子就是LoG算子

- Canny边缘检测：判断一个像素是否在边缘上

  检测步骤：

  1. 使用一个高斯滤波器平滑输入图像
  2. 计算梯度幅度图像和角度图像
  3. 对梯度幅度图像应用非极大值抑制
  4. 使用双阀值处理和连通性分析来检测与连接边缘

  特点：

  - 低错误率。所有边缘都应被找到，并且少有虚假响应
  - 边缘点定位效果好。已定位的边缘必须尽可能接近真实边缘。由检测子标记为边缘的点和真实边缘的中心之间的距离应最小
  - 单个边缘点响应。对于每个真实边缘点，检测子应只返回一个点。真实边缘周围的局部最大数应最小，意味着检测子不应识别只存在单个边缘点的多个边缘像素

- Hough变换：构造区域之间的边界

  - 特征

    - 可以对抗边缘图像中的噪声和缺口
    - 在参数空间中寻找解决方案
    - 经典的霍夫变换
      - 对简单形状的检测
      - 直线检测
      - 圆检测

    - 广义的霍夫变换，检测复杂形状

  - 参数空间离散化，投票法

    当直线趋近于垂直方向时，𝒂（直线的斜率）趋于无穷大。一种解决方法是，使用直线的法线表示：$x\cos{\theta} + y\sin{\theta} = \rho$




## 阈值处理

> 阈值处理这里的目的是图像分割

分割后的图像由下式给出

$$
g(x, y) = 
\begin{cases} 
1, & \text{if } f(x, y) > T \\
0, & \text{if } f(x, y) \leq T 
\end{cases}
$$

即任意一点 $(x, y)$ 的灰度值满足 $f(x, y) > T$，则被称为前景点；否则被称为背景点。$T$ 是阈值，可以用下式表示

$$
G = T[x, y, p(x, y), f(x, y)] \quad p(x, y) \text{像素邻域的一些局部性质}
$$


阈值分割的关键是如何确定适合的阈值 $T$，不同的阈值其处理结果差异很大，会影响特征测量与分析等后续过程。

- 全局阈值（单阈值）：$T$ 与各个像素的灰度有关
- 局部阈值：$T$ 与像素本身及其局部性质（如邻域的平均灰度）有关
- 动态阈值/自适应阈值：$T$ 与局部性质及像素位置有关



- 噪声
- 光照和反射

下面介绍一种迭代算法确定全局阈值的方法：迭代算法确定全局阈值

1. 为全局值T选择一个初始估计值
   - 如果前景和背景占据面积相近，那么平均灰度可能是较好的T的初始值
   - 如果前景和背景占据面积不相近，那么最大灰度值和最小灰度值的平均值可能是较好的T的初始值
2. 用T分割图像。产生两组像素：灰度值大于T的G1，小于等于T的G2
3. 分别对两组像素G和G2计算平均灰度值，得到m1和m2 
4. 在m1和m2之间计算一个新的阈值，$T=\frac{1}{2}(m_1+m_2)$
5. 重复步骤2-4，直到连续迭代的两个T值的差的绝对值小于某个预定义的值△T为止

确定全局值的方法很多，如极小点值法、送代值法、最优國值法、 Otsu值法、最大熵法、p参数法等（实际运用中通常多试几种得到最适合的哪一个）

这里我们介绍一下一种比较常用的方法：Otsu（大津法）最优全局國值处理

- 基本思想：使得图像分割目的就是要使类别之间的差别最大，类内之间的差别最小

- 基本流程：

  1. 设图像总像素数为 $N$，灰度级总数为 $L$，灰度值为 $i$ 的像素数为 $N_i$。令 $p(k)$ 和 $\mu(k)$ 分别表示从灰度级 0 到灰度级 $k$ 的像素的出现概率和平均灰度。分别表示为
     $$
     p(k) = \sum_{i=0}^{k} \frac{N_i}{N}
     $$

     $$
     \mu(k) = \sum_{i=0}^{k} \frac{i \cdot N_i}{N}
     $$

     则，所有像素的总概率为 1，图像的平均灰度为 $\mu_T = \mu(L-1)$

  2. 设图像被分割为 $M$ 个像素类 $C_j$，其统计特性计算如下：

     - 类概率计算：类 $C_j$ 的概率：
       $$
       p_j = p(t_j) - p(t_{j-1})
       $$

     - 类平均灰度：类 $C_j$ 的平均灰度：
       $$
       \mu_j = \frac{\mu(t_j) - \mu(t_{j-1})}{p_j-p_{j-1}}
       $$

     - 类方差计算：类 $C_j$ 的方差：
       $$
       \sigma_j^2 = \sum_{i=t_{j-1}+1}^{t_j} \left( i - \mu_j \right)^2 \frac{p(i)}{p_j}
       $$

    3. 阈值分割约束
       设 $M-1$ 个分割阈值满足：
       $$
        0 \leq t_1 < t_2 < \cdots < t_{M-1} \leq L-1
       $$

        将灰度区间划分为：

       $$
       C_j = [t_{j-1}, t_j] \quad (j=1,2,...,M) \quad \text{且} \quad t_0=0,\ t_M=L-1
       $$

    4. 类内方差
       $$
       \sigma_W^2(t_1, t_2, \cdots, t_{M-1}) = \sum_{j=1}^{M} p_j \cdot \sigma_j^2
       $$

       类间方差
       $$
       \sigma_B^2(t_1, t_2, \cdots, t_{M-1}) = \sum_{j=1}^{M} p_j \cdot (\mu_j - \mu_T)^2
       $$
       将使类内方差最小或使类间方差最大的值组（t1，t2，，tM-1）作为阈值化的最佳阈值组。若取M=2，即分成两类，则可用上述方法求出二值化的最佳值

- 可变阈值处理

  在光照不均匀的情况下，采用全局阈值进行分割通常会取得较差的效果

  最简单的解决方法：将图片分为数个子图，为每一个子图选择对应的阈值𝑻

  假设只有前景和背景：
  - 类型1：对于所有子图像，如果灰度方差 < $  T_1  $，则它们不包含对象边界
  - 类型2：对于所有子图像，如果灰度方差 > $  T_2  $，则它们包含对象边界

  将所有类型1的子图像合并，并使用单个阈值进行阈值处理
  每个类型2的子图像将独立进行阈值处理



## 基于区域的分割方法

此类算法直接寻找区域， 而不是划分区域的边界

- 区域生长

  - 核心思想：从种子点出发，逐步合并相似邻域像素，形成区域

    归类：具有与种子相似的属性的相邻像素，例如特定灰度级或颜色范围

  - 适用范围：适合目标特征明确且与背景差异明显的场景（如单色物体、医学器官分割）

  - 步骤：

    1. 种子选择：手动或自动选择初始种子点（如基于灰度极值或用户标注）。需要先验知识选取种子像素

       > 区域生长法需要根据先验知识选取种子像素。当没有先验知识时，区域生长法存在困难

    2. 相似性准则：定义像素合并条件（如颜色差<阈值、纹理相似性）。

    3. 区域扩展：将邻域像素与当前区域比较，满足条件则合并。

    4. 终止条件：无法合并新像素时停止（如所有邻域不满足相似性）

- 区域分离与聚合

  - 核心思想：从整幅图像出发，递归分裂成子区域，再合并相似区域。

  - 适用范围：适用于复杂图像，尤其是区域边界模糊或存在多个目标的场景（如自然场景分割）

  - 步骤：

    1. 初始划分：将图像划分为均等小块

       将图像分成若干个子区域， 常用四叉树来表示

    2. 分裂阶段：若子区域不满足某种一致性准则(一般用灰度均值和方差来度量)， 则将其继续分裂成若干个子区域， 否则该子区域不再分裂

       通常基于**四叉树**来表示区域分离与聚合，每次将不满足一致性准则的区域分裂为四个大小相等且互不重叠的子区域

    3. 合并阶段：相邻区域若满足相似性准则（如颜色均值接近），则合并

       满足某个相似性准则， 则合并为一个区域， 直到没有可以分裂和合并的子区域为止

    4. 迭代优化：重复分裂与合并，直到区域稳定。



## 基于聚类和超像素的分割方法

- k-means区域分割

  - 核心思想：将图像中的每个像素视为一个数据点，基于颜色（RGB/灰度值）或空间位置特征，使用K-means算法将相似像素聚类为K个簇，每个簇的质心颜色代表该区域的主色调，最终实现区域分割

  - 适用范围：适用于颜色分布差异明显、区域内部特征均匀的图像（如自然场景、医学影像、卫星图像）

  - 原理：

    有 $  K  $ 个簇 $  C_1, \ldots, C_k  $，均值分别为 $  m_1, \ldots, m_k  $

    最小平方误差被定义为：
    $$
    D = \sum_{k=1}^{K} \sum_{x_i \in C_k} ||x_i - m_k||^2
    $$
    从所有 $  K  $ 个簇的可能划分中，选择一个使 $  D  $ 最小

  - 步骤：

    1. 设置迭代计数 $  i_c  $ 为 1
    2. 初始化算法：随机选择一组 $  K  $，规定均值 $  m_1(1), \ldots, m_k(1)  $
    3. 将样本分配给聚类：对于每个向量 $  x_i  $ 计算 $  D(x_i, m_k(i_c)), \, k = 1, \ldots K  $ 并将 $  x_i  $ 分配给具有最接近均值的聚类 $  C_j  $
    4. 更新聚类中心：将 $  i_c  $ 加 1，更新均值以获得 $  m_1(i_c), \ldots, m_k(i_c)  $
    5. 完备性验证：重复第三、第四步，计算当前步骤和前几步中平均向量之间的差的欧几里得范数，计算残差 $  E  $，若 $  E \ll T  $，则停止

  - 优点：简单，快速

  - 缺点：

    - 如何合理设置k
    - 对初始中心敏感
    - 对外点敏感
    - 难以检测球形簇
    - 必须假定均值可计算

- SLIC（简单线性迭代聚类）超像素区域分割

  - 要解决的问题：SLIC超像素分割旨在将图像划分为多个紧凑、均匀且边界贴合良好的超像素块，从而简化后续图像处理任务

  - 核心思想：将图像转换到 **CIELAB颜色空间**（兼顾亮度和颜色感知），结合 **空间坐标** 构建5维特征向量（L, a, b, x, y），通过改进的k-means聚类生成超像素。通过限制搜索范围和动态距离度量提升效率与效果。

    > 当然也可以直接在RGB空间进行

  - 适用范围：适用于颜色/纹理差异显著的自然图像、医学影像（如MRI）、卫星图像等。

  - 步骤

    1. 初始化种子点

       - 均匀分布种子点
       - 调整种子至3×3邻域内梯度最小处，避免初始中心落在边缘

    2. 局部聚类：每个种子点周围 **2S×2S** 区域搜索，计算像素与种子的距离
       $$
       D = \sqrt{(\frac{d_c}{m})^2+(\frac{d_s}{S})}
       $$

        - $  d_c  $：LAB颜色距离$  \sqrt{(L_i-L_j)^2 + (a_i-a_j)^2 + (b_i-b_j)^2}  $
        - $  d_s  $：空间距离$  \sqrt{(x_i-x_j)^2 + (y_i-y_j)^2}  $
        - $  m  $：紧凑度参数（通常取10~20），控制颜色与空间的权重。

    3. 迭代优化

    4. 连通性增强：后处理合并不连续小区域，解决欠分割问题

  - 优点：快，消耗少

  - 缺点：初始敏感/纹理局限，小区域问题



## 图割分割算法

- 作为图的图像

  ![image-20250417002047143](E:/notes_in_zju/docs/notes/cs/assets/数字图像处理与机器视觉.assets/image-20250417002047143.png)

  - 每个像素的节点（顶点）

  - 连接每个像素对，$  i, j  $

  - 每个连接（边）有权重 $  W_{ij}  $，度量相似度

  - 相似度与差异成反比（颜色、位置等）
  - 删除不相关部分之间交叉的连接并忽略相似度低（权重低）的连接

- 最小图割（Graph Cut）

  ![image-20250417002347766](E:/notes_in_zju/docs/notes/cs/assets/数字图像处理与机器视觉.assets/image-20250417002347766.png)

  - 割：一组连接，删除后使图断开

  - 割的代价（边的最小总权重）：$cut(A,B) = \sum_{p\in A,q\in B}W_{p,q}$

  - 最小割，给出一个分割结果，实现快速

    但切割权重与切割边数成正比， 往往会产生小的、孤立的部分——归一化修正

- 图割分割算法

  - 核心思想：将图像建模为**带权无向图**，通过求解最小割（Min-Cut）实现能量最小化
  - 优点：通用方法， 可以灵活选择计算节点之间权重（近似度） 的函数
  - 缺点：计算量大，偏好平衡的分割方法， 对孤立点等有效性较差

- GNN/GCN

## 形态学分水岭分割图像

- 基本知识

  - 灰度图像可以看做是一片地形， 像素的灰度值代表该点的地形高度，一张图以x,y和灰度值三维形式表示
  - 在这种地形解释中，有三类点
    - 低洼：属于一个区域极小值的点
    - 汇水盆地/分水岭：在该处水会流入某个局部极小值点
    - 分界线/分水线：在该处水会等可能地流入不止一个局部极小值点
  - 适用降雨法区分这三类点，对分界线进行筑坝
    - 降雨法：首先找出图像中的低洼，给每个低洼赋予不同的标记
    - 落在未标记点上的雨水将向低处流最终到达一个低洼，将低洼的标记赋予该点
    - 如果某点的雨水可能流向多个低洼，则标记为分水线点
    - 所有点处理完毕后，就形成了不同标记的区域和区域之间的分水线
  - 淹没法
    - 假想每个低洼都有一个洞，把整个地形逐渐沉入湖中，则处在水平面以下的低洼不断涌入水流，逐渐填满与低洼相关的汇水盆地
    - 当来自不同低洼的水在某些点将要汇合时，在这些点上筑坝，阻止水流溢出
    - 当水淹没至地形最高点时，筑坝过程停止；最终所有的水坝就形成了分水线，地形就被分成了不同的区域或盆地

- 构建水坝

  - 水坝的构建基于二值图像，使用形态学膨胀方法


  - 水坝的构建必须使水不从不同的汇水盆地中溢出


  - 设 $  M_1  $ 和 $  M_2  $ 为两个区域最小值点的坐标集


  - 汇水盆地中与洪水位 $  n-1  $ 的两个最小值相关点的坐标集是 $  C_{n-1}(M_1)  $ 和 $  C_{n-1}(M_2)  $


  - 两个集合的并集为 $  C[n-1]  $

- 分水岭分割算法

  - 解决的问题：分水岭算法主要用于解决图像中**目标粘连或重叠时的精确分割**问题
  - 适用范围：适用于灰度图像，尤其是**梯度明显**的场景（如边缘清晰的物体、医学影像）
  - 核心思想：将图像视为**地形表面**，灰度值代表海拔高度。低灰度区域为“山谷”（目标内部），高灰度区域为“山峰”（目标边界）。通过模拟水流从山谷逐渐上升并筑坝的过程，分割出独立区域

- 标记的使用

  直接应用分水岭分割算法时，通常会因噪声和梯度的其他局部不规则性导致过渡分割

  一个解决方案是限制区域最小值的数量：使用标记指定唯一允许的区域最小值

  区域标记是指对图像中同一连通区域的所有像素赋予相同的标记，不同的连通区域赋予不同的标记，一个标记就是属于图像的一个连通成分

  常用的区域标记方法有两种： **递归标记和序贯标记**